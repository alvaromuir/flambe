// Generated by CoffeeScript 1.6.3
(function() {
  var assert, chai, crud, expect, mocha, moment, should, tmpUsrs, usrData, _;

  mocha = require('mocha');

  chai = require('chai');

  _ = require('lodash');

  moment = require('moment');

  assert = chai.assert;

  expect = chai.expect;

  should = chai.should();

  crud = require('../lib/crud');

  usrData = require('./data/users');

  tmpUsrs = [];

  describe("quick addition test", function() {
    return it("is expected to add 1+1 correctly", function(done) {
      var onePlusOne;
      onePlusOne = 1 + 1;
      expect(onePlusOne).to.equal(2);
      return done();
    });
  });

  describe("Database setup", function() {
    it("should return the db name, 'flambe_test'", function(done) {
      var current_db;
      current_db = crud.setup.db.connections[0].name;
      current_db.should.equal('flambe_test');
      return done();
    });
    return it("should have a 'User' schema", function(done) {
      _.contains(crud.setup.schemaList, 'User').should.equal(true);
      done();
      return describe("schema operations", function() {
        var User, count, random_usr, total;
        User = crud.User;
        total = usrData.length;
        random_usr = usrData[_.random(0, total - 1)];
        count = 1;
        before(function(done) {
          var tmpUserModel;
          tmpUserModel = crud.setup.models['User'];
          return tmpUserModel.remove({}, function(err) {
            return done();
          });
        });
        it("should be able to create users", function(done) {
          return _.forEach(usrData, function(usr) {
            return User.create(usr, function(rslt) {
              tmpUsrs.push(rslt);
              count += 1;
              if (count === total) {
                return done();
              }
            });
          });
        });
        it("should be able to find users by criteria", function(done) {
          var query, queryRslt, random_key, usr;
          usr = random_usr;
          random_key = _.keys(usr)[_.random(0, _.keys(usr).length - 1)];
          query = {};
          query[random_key] = usr[random_key];
          queryRslt = '';
          User.read(query, function(rslt) {
            queryRslt = rslt[0];
            rslt[0][random_key].should.equal(usr[random_key]);
            return done();
          });
          return describe("which have appropriate defaults that", function() {
            return it("is expected to have a creation date", function(done) {
              expect(queryRslt.createdOn).to.be.a('date');
              return done();
            });
          });
        });
        it("should be able to find a user by ID", function(done) {
          random_usr = tmpUsrs[_.random(0, total - 1)];
          return User.readById(random_usr._id, function(rslt) {
            rslt.displayName.should.equal(random_usr.displayName);
            return done();
          });
        });
        it("should be able to find a single user by criteria", function(done) {
          var match, query;
          match = /rocknation.com/i;
          query = {
            email: match
          };
          return User.readOne(query, function(rslt) {
            match.test(rslt.email).should.equal(true);
            return done();
          });
        });
        it("should be able to update records by criteria", function(done) {
          var match, query;
          match = /rocknation.com/i;
          query = {
            email: match
          };
          return User.read(query, function(rslt) {
            total = rslt.length;
            count = 0;
            return _.forEach(rslt, function(rcrd) {
              var emailName, update;
              emailName = rcrd.email.split('@')[0];
              query = {
                email: rcrd.email
              };
              update = {
                email: emailName + '@defjam.com'
              };
              return User.update(query, update, function(err, num, raw) {
                if (err) {
                  done(err);
                }
                return User.readById({
                  _id: rcrd._id
                }, function(rslt) {
                  rslt.email.should.equal(update.email);
                  count += 1;
                  if (count === total) {
                    return done();
                  }
                });
              });
            });
          });
        });
        it("should be able to update a record by ID", function(done) {
          var updates;
          random_usr = tmpUsrs[_.random(0, total - 1)];
          updates = {
            status: 'updated by id test suite on ' + moment().toString()
          };
          return User.updateByID(random_usr._id, updates, function(err, rslt) {
            rslt.status.should.equal(updates.status);
            return done();
          });
        });
        it("should be able to update a single record by criteria", function(done) {
          var query, random_key, updates;
          random_usr = _.clone(tmpUsrs[_.random(0, total - 1)])._doc;
          delete random_usr.__v;
          delete random_usr.verified;
          delete random_usr.validated;
          random_key = _.keys(random_usr)[_.random(0, _.keys(random_usr).length - 1)];
          query = {};
          query[random_key] = random_usr[random_key];
          updates = {
            status: 'updated by criteria in test suite on ' + moment().toString()
          };
          return User.updateOne(query, updates, function(err, rslt) {
            if (err) {
              done(err);
            }
            return done();
          });
        });
        it("should be able to delete records by criteria", function(done) {
          var query, random_key;
          random_usr = _.clone(tmpUsrs[_.random(0, total - 1)])._doc;
          delete tmpUsrs[random_usr];
          delete random_usr.__v;
          delete random_usr.verified;
          delete random_usr.validated;
          random_key = _.keys(random_usr)[_.random(0, _.keys(random_usr).length - 1)];
          query = {};
          query[random_key] = random_usr[random_key];
          return User.read(query, function(rslt) {
            return User["delete"](rslt[0], function(err) {
              return User.readById(rslt[0]._id, function(err, rslt) {
                if (err) {
                  done(err);
                }
                expect(rslt).to.be.undefined;
                return done();
              });
            });
          });
        });
        it("should be able to delete a record by ID", function(done) {
          random_usr = _.clone(tmpUsrs[_.random(0, total - 1)])._doc;
          delete tmpUsrs[random_usr];
          return User.deleteByID(random_usr._id, {}, function(rslt) {
            return done();
          });
        });
        it("should be able to delete a single record by criteria", function(done) {
          var query, random_key;
          random_usr = _.clone(tmpUsrs[_.random(0, total - 1)])._doc;
          delete tmpUsrs[random_usr];
          delete random_usr.__v;
          delete random_usr.verified;
          delete random_usr.validated;
          random_key = _.keys(random_usr)[_.random(0, _.keys(random_usr).length - 1)];
          query = {};
          query[random_key] = random_usr[random_key];
          return User.deleteOne(query, {}, function(err, rslt) {
            return User.readOne(query, function(err, rslt) {
              if (err) {
                done(err);
              }
              expect(rslt).to.be.undefined;
              return done();
            });
          });
        });
        return it("should be able to delete records quickly", function(done) {
          total = tmpUsrs.length;
          count = 0;
          return _.forEach(tmpUsrs, function(usr) {
            var query;
            query = {
              _id: usr._id
            };
            User.deleteQuick(query);
            count += 1;
            if (count === total) {
              return User.count({}, function(rslt) {
                expect(rslt).to.equal(0);
                return done();
              });
            }
          });
        });
      });
    });
  });

}).call(this);
